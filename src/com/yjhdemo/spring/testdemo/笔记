第一步 引入依赖
spring-aop-5.2.6.RELEASE.jar
第二步开启组件扫描
<!--首先要引入名称空间-->
<!--    开启组建扫描
1.扫描多个包用逗号隔开
2.扫描包的上层目录
-->
    <context:component-scan base-package="com.yjhdemo.spring.testdemo"></context:component-scan>
第三步创建类 在类上面添加创建对象的注解

import org.springframework.stereotype.Service;
//在注解里面value属性值可以省略不写，
//默认是类名称，首字母小写
@Component(value = "userService") //类似<bean id ="username" class= "..."/>
public class UserService {
    public void  add(){
        System.out.println("service add .................");
    }
}
注解后面的括号里如果bu用value = “xxx” 默认是类名称首字母小写
测试类写法
@Test
    public void testService(){
        ApplicationContext context = new ClassPathXmlApplicationContext("Bean1.xml");
        UserService userService = context.getBean("userService", UserService.class);
        System.out.println(userService);
        userService.add();
    }
    这里注解中value后面的值就相当于在xml中的id
<!--示例1
        添加use-default-filters="false"表示现在不在使用默认的filters，自己配置filters
        context:include-filter 设置扫描的内容
-->
    <context:component-scan base-package="com.yjhdemo.spring.testdemo" use-default-filters="false">
        <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
<!--    实例2
下面配置扫描包所有内容
context：exclude-filter 设置哪些内容bu进行扫描
-->
    <context:component-scan base-package="com.yjhdemo.spring.testdemo" use-default-filters="false">
    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    5.基于注解方式实现属性注入
    （1）@Autowired:根据属性类型进行自动装配
    第一步 把service 和dao 对象创建，在service和到类添加创建对象注解
    第二步在service中注入dao对象 在sercvice类添加dao类型属性，在属性上面使用注解
    （2）@Qualifier 根据属性名称进行注入
                public class UserService {
                //    定义到类型属性
                //    不需要添加set方法
                //    添加注入属性注解
                    @Autowired
                    @Qualifier (value = "impl1")
                    private UserDao userDao;
                    public void  add(){
                        System.out.println("service add .................");
                        userDao.add();
                    }
                }
    （3）@Resource 可以根据类型注入，可以根据名称注入
    （4） Value 注入普通类型属性
    6.纯注解开发
    （1）创建配置类，替代xml的配置文件
    @Configuration //作为配置类，替代xml配置文件
    @ComponentScan(basePackages = {"com.yjhdemo.spring.testdemo"})
    （2）编写测试类
     @Test
        public void testService1(){
            ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
            UserService userService = context.getBean("userService", UserService.class);
            System.out.println(userService);
            userService.add();
        }
（1）Aop 面向切面，不修改原代码进行功能增强
AOP（概念）
1、什么是AOP
（1）面向切面编程利用AOP可以对业务逻辑进行隔离，从使逻辑部分直接的耦合降低，提高程序的可重用性，同时提高开发效率
（2）不通过修改原代码的方式在主干添加新功能
AOP的底层原理
1.AOP底层使用了动态代理
第一种有接口 使用JDK动态代理
创建接口实现类代理对象，增强类的方法原理图见AOP原理图.png
第二种没有接口情况使用CGLIB动态代理
AOP（JDK动态代理）
1.使用JDK动态代理，使用Proxy类里面的方法创建代理对象
调用jdk8的newProxyInstance方法
方法有三个参数
第一个参数   类加载器
第二个参数   怎去方法所在的类。这个类实现的接口，支持对公接口
第三个参数   实现这个接口InvocationHandler,创建代理对象，写怎去的方法
（1）创建接口，定义方法
（2）创建接口实现类，实现方法
(3)使用Proxy类创建接口代理对象
在主方法中运行的部分
        UserDaoImpl userDao = new UserDaoImpl(); ---------------------->实例化实现类
        UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); --------->传参
        int result =dao.add(1,2);   ------->调用方法
        System.out.println(result);

        参数所需要的类
          static class UserDaoProxy implements InvocationHandler {
                //            把创建是谁的代理对象，把谁传递过来
        //在这个方法里写增强的部分代码
                private Object obj;
                public UserDaoProxy(Object obj) {
                    this.obj =obj;
                }

                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //            方法之前
                    System.out.println("方法执行之前=======================================>"+method.getName()+"======<参数列表"+ Arrays.toString(args));
        //            被增强的方法执行
                    Object invokes = method.invoke(obj, args);
        //            方法之后
                    System.out.println("方法执行之后=======================================>"+obj);
                    return invokes;
                }
            }
            AOP（术语）
            1.连接点
            2.切入点
            3.通知（增强）
            4.切面




